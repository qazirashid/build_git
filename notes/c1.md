# Commit 01

I think the first commit will be the hardest to understand. If I can digest it then later commits should become easier. Let's give it a go. 

Let's copy across the files in the first commit from the git repo to src directory in this repo, and commit it to this repo.

There are a few things I could do to start. I could start with the 'README' that Linus wrote for the first commit. Or I could start building to see if I can build the first commit. Or I could jump in and start reading the code. 

I guess we can start noting an observation and then skim the 'README'.

## Early Observations 
1. There are 8 .c files that Linus wrote. He did not start one huge .c file to begin with. 
2. Looking at the Makefile, Linus builds 6 executable files from the source files. This again seem rather large number of programs for the first commit. 
3. The 6 programs are 'update-cache', 'show-diff', 'write-tree', 'read-tree', 'commit-tree' and 'cat-file'. Looks like these are component programs that will be glued together at some later stage. 
4. the build target 'init-db' has a dependency 'init-db.o' but no rule for building it. I think Linus will initialise the db (don't know what that is) mannually. That is a bit of problem because I won't know what he did because it won't be caputred in the history. 
5. The Makefile has a 'backup' target that depends on 'clean'. It requires cleaning up the repo and then runing tar on a directory named 'dir-cache' to generate a compressed archive. 

6. In the 'README' file, Linus calls it 'git - the stupid content tracker' and later calls it 'directoy content tracker'. He does not use the term 'version control'. He says that this content tracker doesn't do much but it efficiently tracks the directory contents. 

7. He defines to object abstractions. a) the `object database` and b) the `current directory cache`. He then goes into detail about each. It's not feasible to repeat or summarise it here. Its best to go and read it in the 'README' in the `src` directory. 

8. The `object database` is a content-addressable collection of objects. All objects are named based on the SHA1 hash of their contents. 

9. The objects in the `object database` can refer to other objects by using their SHA1 hash. 
10. There are several types of objects in the `object database`. For each object, the content is compressed (deflated using zlib). They start off with the tag indicating their type, followed by the size information and followed by data. All of this is compressed and its SHA1 hash is calculated to store it in the `object database`. 
11. Any object in the `object database` can be validated by checking its SHA1 hash, which should match its name in the `object database`. 
12. When an object is inflated, it must inflate to a stream of bytes that forms a sequence of \<ascii tage without the space> + \<space> + \<decimal size in ascii> + \<byte\0> + \<binary object content>. 
